// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: image_updates.sql

package pgdb

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countImageUpdates = `-- name: CountImageUpdates :one
SELECT COUNT(*)
FROM image_updates
`

func (q *Queries) CountImageUpdates(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countImageUpdates)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageUpdatesWithErrors = `-- name: CountImageUpdatesWithErrors :one
SELECT COUNT(*)
FROM image_updates
WHERE last_error IS NOT NULL
`

func (q *Queries) CountImageUpdatesWithErrors(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countImageUpdatesWithErrors)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageUpdatesWithUpdate = `-- name: CountImageUpdatesWithUpdate :one
SELECT COUNT(*)
FROM image_updates
WHERE has_update = true
`

func (q *Queries) CountImageUpdatesWithUpdate(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countImageUpdatesWithUpdate)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countImageUpdatesWithUpdateType = `-- name: CountImageUpdatesWithUpdateType :one
SELECT COUNT(*)
FROM image_updates
WHERE has_update = true
	AND update_type = $1
`

func (q *Queries) CountImageUpdatesWithUpdateType(ctx context.Context, updateType pgtype.Text) (int64, error) {
	row := q.db.QueryRow(ctx, countImageUpdatesWithUpdateType, updateType)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteImageUpdatesByIDs = `-- name: DeleteImageUpdatesByIDs :execrows
DELETE FROM image_updates
WHERE id = ANY($1::text[])
`

func (q *Queries) DeleteImageUpdatesByIDs(ctx context.Context, dollar_1 []string) (int64, error) {
	result, err := q.db.Exec(ctx, deleteImageUpdatesByIDs, dollar_1)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const getImageUpdateByID = `-- name: GetImageUpdateByID :one
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE id = $1
LIMIT 1
`

type GetImageUpdateByIDRow struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) GetImageUpdateByID(ctx context.Context, id string) (*GetImageUpdateByIDRow, error) {
	row := q.db.QueryRow(ctx, getImageUpdateByID, id)
	var i GetImageUpdateByIDRow
	err := row.Scan(
		&i.ID,
		&i.Repository,
		&i.Tag,
		&i.HasUpdate,
		&i.UpdateType,
		&i.CurrentVersion,
		&i.LatestVersion,
		&i.CurrentDigest,
		&i.LatestDigest,
		&i.CheckTime,
		&i.ResponseTimeMs,
		&i.LastError,
		&i.AuthMethod,
		&i.AuthUsername,
		&i.AuthRegistry,
		&i.UsedCredential,
		&i.NotificationSent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listImageUpdates = `-- name: ListImageUpdates :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
`

type ListImageUpdatesRow struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListImageUpdates(ctx context.Context) ([]*ListImageUpdatesRow, error) {
	rows, err := q.db.Query(ctx, listImageUpdates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImageUpdatesRow{}
	for rows.Next() {
		var i ListImageUpdatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImageUpdatesByIDs = `-- name: ListImageUpdatesByIDs :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE id = ANY($1::text[])
`

type ListImageUpdatesByIDsRow struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListImageUpdatesByIDs(ctx context.Context, dollar_1 []string) ([]*ListImageUpdatesByIDsRow, error) {
	rows, err := q.db.Query(ctx, listImageUpdatesByIDs, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImageUpdatesByIDsRow{}
	for rows.Next() {
		var i ListImageUpdatesByIDsRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listImageUpdatesWithUpdate = `-- name: ListImageUpdatesWithUpdate :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE has_update = true
`

type ListImageUpdatesWithUpdateRow struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListImageUpdatesWithUpdate(ctx context.Context) ([]*ListImageUpdatesWithUpdateRow, error) {
	rows, err := q.db.Query(ctx, listImageUpdatesWithUpdate)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImageUpdatesWithUpdateRow{}
	for rows.Next() {
		var i ListImageUpdatesWithUpdateRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUnnotifiedImageUpdates = `-- name: ListUnnotifiedImageUpdates :many
SELECT id,
			 repository,
			 tag,
			 has_update,
			 update_type,
			 current_version,
			 latest_version,
			 current_digest,
			 latest_digest,
			 check_time,
			 response_time_ms,
			 last_error,
			 auth_method,
			 auth_username,
			 auth_registry,
			 used_credential,
			 notification_sent,
			 created_at,
			 updated_at
FROM image_updates
WHERE has_update = true
	AND notification_sent = false
`

type ListUnnotifiedImageUpdatesRow struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ListUnnotifiedImageUpdates(ctx context.Context) ([]*ListUnnotifiedImageUpdatesRow, error) {
	rows, err := q.db.Query(ctx, listUnnotifiedImageUpdates)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListUnnotifiedImageUpdatesRow{}
	for rows.Next() {
		var i ListUnnotifiedImageUpdatesRow
		if err := rows.Scan(
			&i.ID,
			&i.Repository,
			&i.Tag,
			&i.HasUpdate,
			&i.UpdateType,
			&i.CurrentVersion,
			&i.LatestVersion,
			&i.CurrentDigest,
			&i.LatestDigest,
			&i.CheckTime,
			&i.ResponseTimeMs,
			&i.LastError,
			&i.AuthMethod,
			&i.AuthUsername,
			&i.AuthRegistry,
			&i.UsedCredential,
			&i.NotificationSent,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markImageUpdatesNotified = `-- name: MarkImageUpdatesNotified :exec
UPDATE image_updates
SET notification_sent = true,
		updated_at = NOW()
WHERE id = ANY($1::text[])
`

func (q *Queries) MarkImageUpdatesNotified(ctx context.Context, dollar_1 []string) error {
	_, err := q.db.Exec(ctx, markImageUpdatesNotified, dollar_1)
	return err
}

const saveImageUpdate = `-- name: SaveImageUpdate :one
INSERT INTO image_updates (
		id,
		repository,
		tag,
		has_update,
		update_type,
		current_version,
		latest_version,
		current_digest,
		latest_digest,
		check_time,
		response_time_ms,
		last_error,
		auth_method,
		auth_username,
		auth_registry,
		used_credential,
		notification_sent,
		created_at,
		updated_at
)
VALUES (
		$1,
		$2,
		$3,
		$4,
		$5,
		$6,
		$7,
		$8,
		$9,
		$10,
		$11,
		$12,
		$13,
		$14,
		$15,
		$16,
		$17,
		NOW(),
		NOW()
)
ON CONFLICT (id) DO UPDATE SET
		repository = EXCLUDED.repository,
		tag = EXCLUDED.tag,
		has_update = EXCLUDED.has_update,
		update_type = EXCLUDED.update_type,
		current_version = EXCLUDED.current_version,
		latest_version = EXCLUDED.latest_version,
		current_digest = EXCLUDED.current_digest,
		latest_digest = EXCLUDED.latest_digest,
		check_time = EXCLUDED.check_time,
		response_time_ms = EXCLUDED.response_time_ms,
		last_error = EXCLUDED.last_error,
		auth_method = EXCLUDED.auth_method,
		auth_username = EXCLUDED.auth_username,
		auth_registry = EXCLUDED.auth_registry,
		used_credential = EXCLUDED.used_credential,
		notification_sent = EXCLUDED.notification_sent,
		updated_at = NOW()
RETURNING id,
					repository,
					tag,
					has_update,
					update_type,
					current_version,
					latest_version,
					current_digest,
					latest_digest,
					check_time,
					response_time_ms,
					last_error,
					auth_method,
					auth_username,
					auth_registry,
					used_credential,
					notification_sent,
					created_at,
					updated_at
`

type SaveImageUpdateParams struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
}

type SaveImageUpdateRow struct {
	ID               string             `json:"id"`
	Repository       string             `json:"repository"`
	Tag              string             `json:"tag"`
	HasUpdate        bool               `json:"has_update"`
	UpdateType       pgtype.Text        `json:"update_type"`
	CurrentVersion   string             `json:"current_version"`
	LatestVersion    pgtype.Text        `json:"latest_version"`
	CurrentDigest    pgtype.Text        `json:"current_digest"`
	LatestDigest     pgtype.Text        `json:"latest_digest"`
	CheckTime        pgtype.Timestamptz `json:"check_time"`
	ResponseTimeMs   int32              `json:"response_time_ms"`
	LastError        pgtype.Text        `json:"last_error"`
	AuthMethod       pgtype.Text        `json:"auth_method"`
	AuthUsername     pgtype.Text        `json:"auth_username"`
	AuthRegistry     pgtype.Text        `json:"auth_registry"`
	UsedCredential   pgtype.Bool        `json:"used_credential"`
	NotificationSent pgtype.Bool        `json:"notification_sent"`
	CreatedAt        pgtype.Timestamptz `json:"created_at"`
	UpdatedAt        pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) SaveImageUpdate(ctx context.Context, arg SaveImageUpdateParams) (*SaveImageUpdateRow, error) {
	row := q.db.QueryRow(ctx, saveImageUpdate,
		arg.ID,
		arg.Repository,
		arg.Tag,
		arg.HasUpdate,
		arg.UpdateType,
		arg.CurrentVersion,
		arg.LatestVersion,
		arg.CurrentDigest,
		arg.LatestDigest,
		arg.CheckTime,
		arg.ResponseTimeMs,
		arg.LastError,
		arg.AuthMethod,
		arg.AuthUsername,
		arg.AuthRegistry,
		arg.UsedCredential,
		arg.NotificationSent,
	)
	var i SaveImageUpdateRow
	err := row.Scan(
		&i.ID,
		&i.Repository,
		&i.Tag,
		&i.HasUpdate,
		&i.UpdateType,
		&i.CurrentVersion,
		&i.LatestVersion,
		&i.CurrentDigest,
		&i.LatestDigest,
		&i.CheckTime,
		&i.ResponseTimeMs,
		&i.LastError,
		&i.AuthMethod,
		&i.AuthUsername,
		&i.AuthRegistry,
		&i.UsedCredential,
		&i.NotificationSent,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const updateImageUpdateHasUpdateByRepositoryTag = `-- name: UpdateImageUpdateHasUpdateByRepositoryTag :exec
UPDATE image_updates
SET has_update = $3,
		updated_at = NOW()
WHERE repository = $1
	AND tag = $2
`

type UpdateImageUpdateHasUpdateByRepositoryTagParams struct {
	Repository string `json:"repository"`
	Tag        string `json:"tag"`
	HasUpdate  bool   `json:"has_update"`
}

func (q *Queries) UpdateImageUpdateHasUpdateByRepositoryTag(ctx context.Context, arg UpdateImageUpdateHasUpdateByRepositoryTagParams) error {
	_, err := q.db.Exec(ctx, updateImageUpdateHasUpdateByRepositoryTag, arg.Repository, arg.Tag, arg.HasUpdate)
	return err
}
